<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tarot Table üîÆ</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff8e1;
      font-family: "Segoe UI", sans-serif;
      font-size: 20px;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
</head>
<body>
  <div id="loading">üîÆ Loading...</div>

  <script>
    const scene = new THREE.Scene();

    //‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á
    const textureLoader = new THREE.TextureLoader();
    textureLoader.load("./bg.png", (texture) => {
      scene.background = texture;
    });

    //‡∏Å‡∏•‡πâ‡∏≠‡∏á
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.position.set(0, 190, 650);
    camera.lookAt(0, 100, 0);

    //Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    //Controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 100, 0);
    controls.enableDamping = true;
    controls.enableZoom = true;
    controls.minDistance = 300;
    controls.maxDistance = 1000;

    //‡πÅ‡∏™‡∏á
    const ambient = new THREE.AmbientLight(0xffffff, 0.5);
    const keyLight = new THREE.SpotLight(0xfff6d9, 1.5);
    keyLight.position.set(250, 400, 200);
    keyLight.castShadow = true;
    keyLight.angle = Math.PI / 4;
    keyLight.penumbra = 0.4;
    const fillLight = new THREE.PointLight(0x77aaff, 0.6);
    fillLight.position.set(-300, 200, 100);
    const rimLight = new THREE.PointLight(0xffaa88, 0.8);
    rimLight.position.set(0, 300, -300);
    scene.add(ambient, keyLight, fillLight, rimLight);

    const loader = new THREE.GLTFLoader();
    let profileText = null, randomButton = null, ghostModel = null;

    // ‡πÇ‡∏ï‡πä‡∏∞
    loader.load("./random1.glb", (gltf) => {
      const model = gltf.scene;
      model.scale.set(100, 100, 100);
      scene.add(model);
    });

    // ‡πÇ‡∏õ‡∏£‡πÑ‡∏ü‡∏•‡πå
    loader.load("./T_5.glb", (gltf) => {
      profileText = gltf.scene;
      profileText.scale.set(80, 80, 80);
      profileText.position.set(20, 6, 0);
      scene.add(profileText);
    });

    // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏™‡∏∏‡πà‡∏°
    loader.load("./TR_3.glb", (gltf) => {
      randomButton = gltf.scene;
      randomButton.scale.set(80, 80, 80);
      randomButton.position.set(-250, -80, 0);
      scene.add(randomButton);

      const randomLight = new THREE.PointLight(0x88ccff, 1.2, 250);
      randomLight.position.set(250, 50, 100);
      scene.add(randomLight);

      document.getElementById("loading").style.display = "none";
    });

    //‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ú‡∏µ
    loader.load("./ghost.glb", (gltf) => {
      ghostModel = gltf.scene;
      ghostModel.scale.set(40, 40, 40);
      ghostModel.position.set(0, 160, -300);
      scene.add(ghostModel);

      // ‡πÅ‡∏™‡∏á‡∏ü‡πâ‡∏≤‡∏£‡∏≠‡∏ö‡∏ú‡∏µ
      const ghostLight = new THREE.PointLight(0x88ccff, 2, 400);
      ghostLight.position.set(0, 160, -300);
      scene.add(ghostLight);

      ghostModel.userData.light = ghostLight; // ‡∏ú‡∏π‡∏Å‡πÑ‡∏ü‡πÑ‡∏ß‡πâ‡∏Å‡∏±‡∏ö‡∏ú‡∏µ
    });

    //‡∏ù‡∏∏‡πà‡∏ô‡∏•‡∏≠‡∏¢
    const particleCount = 450;
    const particlesGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    for (let i = 0; i < particleCount * 3; i++) positions[i] = (Math.random() - 0.5) * 2000;
    particlesGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

    const particlesMaterial = new THREE.PointsMaterial({
      color: 0xffdd99,
      size: 4,
      transparent: true,
      opacity: 0.6,
      blending: THREE.AdditiveBlending
    });

    const particles = new THREE.Points(particlesGeometry, particlesMaterial);
    particlesMaterial.depthWrite = false;
    scene.add(particles);

    //‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Å‡∏ï‡πå‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß
    let ghostAngle = 0;
    function animateParticlesAndGhost() {
      const t = Date.now() * 0.0002;
      particles.rotation.y = t * 0.3;
      particles.rotation.x = Math.sin(t * 0.1) * 0.15;

      //‡∏ú‡∏µ‡∏•‡∏≠‡∏¢‡∏´‡∏°‡∏∏‡∏ô‡∏£‡∏≠‡∏ö‡πÇ‡∏ï‡πä‡∏∞
      if (ghostModel) {
        ghostAngle += 0.005;
        const radius = 300;
        ghostModel.position.x = Math.cos(ghostAngle) * radius;
        ghostModel.position.z = Math.sin(ghostAngle) * radius - 100;
        ghostModel.position.y = 150 + Math.sin(t * 2) * 30; // ‡∏•‡∏≠‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô‡∏•‡∏á‡πÄ‡∏ö‡∏≤ ‡πÜ

        // ‡πÅ‡∏™‡∏á‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß‡∏ï‡∏≤‡∏°‡∏ú‡∏µ
        ghostModel.userData.light.position.copy(ghostModel.position);
      }
    }

    //‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Ñ‡∏•‡∏¥‡∏Å
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    window.addEventListener("click", (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      if (profileText && raycaster.intersectObject(profileText, true).length > 0)
        window.location.href = "./name.html";

      if (randomButton && raycaster.intersectObject(randomButton, true).length > 0)
        window.location.href = "./random.html";
    });

    //Loop
    function animate() {
      requestAnimationFrame(animate);
      animateParticlesAndGhost();
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    //Resize
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>



