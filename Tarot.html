<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Tarot Table üîÆ</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }

    /*‡∏´‡∏ô‡πâ‡∏≤‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î */
    #loadingOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(180deg, #5b2e91 0%, #2d0b52 100%);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      transition: opacity 1s ease;
      color: #fff0ff;
      font-family: "Segoe UI", sans-serif;
    }

    #loadingText {
      font-size: 22px;
      margin-bottom: 20px;
      text-shadow: 0 0 12px rgba(255, 200, 255, 0.8);
      animation: pulseText 1.6s infinite;
    }

    @keyframes pulseText {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.6;
      }
    }

    #progressContainer {
      width: 260px;
      height: 14px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 0 15px rgba(255, 150, 255, 0.3);
    }

    #progressBar {
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, #ffbaff, #b47aff, #ffffff);
      border-radius: 10px;
      box-shadow: 0 0 15px rgba(255, 150, 255, 0.8);
      transition: width 0.2s ease;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
</head>

<body>

  <div id="loadingOverlay">
    <div id="loadingText">üîÆ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡∏û‡∏•‡∏±‡∏á‡πÑ‡∏û‡πà...</div>
    <div id="progressContainer">
      <div id="progressBar"></div>
    </div>
  </div>

  <div id="loading">üîÆ Loading...</div>

  <script>
    const scene = new THREE.Scene();

    const textureLoader = new THREE.TextureLoader();
    textureLoader.load("./bg.png", (texture) => {
      scene.background = texture;
    });

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.position.set(0, 190, 650);
    camera.lookAt(0, 100, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 100, 0);
    controls.enableDamping = true;
    controls.enableZoom = true;
    controls.minDistance = 300;
    controls.maxDistance = 1000;

    const ambient = new THREE.AmbientLight(0xffffff, 0.5);
    const keyLight = new THREE.SpotLight(0xfff6d9, 1.5);
    keyLight.position.set(250, 400, 200);
    keyLight.castShadow = true;
    keyLight.angle = Math.PI / 4;
    keyLight.penumbra = 0.4;
    const fillLight = new THREE.PointLight(0x77aaff, 0.6);
    fillLight.position.set(-300, 200, 100);
    const rimLight = new THREE.PointLight(0xffaa88, 0.8);
    rimLight.position.set(0, 300, -300);
    scene.add(ambient, keyLight, fillLight, rimLight);

    const loader = new THREE.GLTFLoader();
    let profileText = null, randomButton = null, ghostModel = null;
    let loadedModels = 0;
    const totalModels = 4; // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î

    // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå‡πÇ‡∏´‡∏•‡∏î
    function updateProgress() {
      const percent = Math.min(Math.round((loadedModels / totalModels) * 100), 100);
      document.getElementById("progressBar").style.width = percent + "%";
      if (percent === 100) {
        const overlay = document.getElementById("loadingOverlay");
        overlay.style.opacity = 0;
        setTimeout(() => overlay.style.display = "none", 1000);
      }
    }

    // ‡πÇ‡∏ï‡πä‡∏∞
    loader.load("./random1.glb", (gltf) => {
      const model = gltf.scene;
      model.scale.set(100, 100, 100);
      scene.add(model);
      loadedModels++; updateProgress();
    });

    // ‡πÇ‡∏õ‡∏£‡πÑ‡∏ü‡∏•‡πå
    loader.load("./T_5.glb", (gltf) => {
      profileText = gltf.scene;
      profileText.scale.set(80, 80, 80);
      profileText.position.set(20, 6, 0);
      scene.add(profileText);
      loadedModels++; updateProgress();
    });

    // ‡∏õ‡∏∏‡πà‡∏°‡∏™‡∏∏‡πà‡∏°
    loader.load("./TR_3.glb", (gltf) => {
      randomButton = gltf.scene;
      randomButton.scale.set(80, 80, 80);
      randomButton.position.set(-250, -80, 0);
      scene.add(randomButton);

      const randomLight = new THREE.PointLight(0x88ccff, 1.2, 250);
      randomLight.position.set(250, 50, 100);
      scene.add(randomLight);

      loadedModels++; updateProgress();
      document.getElementById("loading").style.display = "none";
    });

    // ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ú‡∏µ
    loader.load("./ghost.glb", (gltf) => {
      ghostModel = gltf.scene;
      ghostModel.scale.set(40, 40, 40);
      ghostModel.position.set(0, 160, -300);
      scene.add(ghostModel);

      //‡πÉ‡∏™‡πà Cel Shading 
      ghostModel.traverse((obj) => {
        if (obj.isMesh) {
          obj.material = new THREE.MeshToonMaterial({
            color: 0x77bbff, 
            gradientMap: null, 
          });
          obj.castShadow = true;
          obj.receiveShadow = true;
        }
      });

      // 
      const ghostLight = new THREE.PointLight(0x88ccff, 2, 400);
      ghostLight.position.set(0, 160, -300);
      scene.add(ghostLight);
      ghostModel.userData.light = ghostLight;

      loadedModels++;
      updateProgress();
    });


    const particleCount = 450;
    const particlesGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    for (let i = 0; i < particleCount * 3; i++) positions[i] = (Math.random() - 0.5) * 2000;
    particlesGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    const particlesMaterial = new THREE.PointsMaterial({
      color: 0xffdd99,
      size: 4,
      transparent: true,
      opacity: 0.6,
      blending: THREE.AdditiveBlending
    });
    const particles = new THREE.Points(particlesGeometry, particlesMaterial);
    particlesMaterial.depthWrite = false;
    scene.add(particles);

    let ghostAngle = 0;
    function animateParticlesAndGhost() {
      const t = Date.now() * 0.0002;
      particles.rotation.y = t * 0.3;
      particles.rotation.x = Math.sin(t * 0.1) * 0.15;
      if (ghostModel) {
        ghostAngle += 0.005;
        const radius = 300;
        ghostModel.position.x = Math.cos(ghostAngle) * radius;
        ghostModel.position.z = Math.sin(ghostAngle) * radius - 100;
        ghostModel.position.y = 150 + Math.sin(t * 2) * 30;
        ghostModel.userData.light.position.copy(ghostModel.position);
      }
    }

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    window.addEventListener("click", (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      if (profileText && raycaster.intersectObject(profileText, true).length > 0)
        window.location.href = "./name.html";
      if (randomButton && raycaster.intersectObject(randomButton, true).length > 0)
        window.location.href = "./random.html";
    });

    function animate() {
      requestAnimationFrame(animate);
      animateParticlesAndGhost();
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>

</html>



